## Часть 2. Производитель-потребитель.
Производитель-потребитель является распространенным шаблоном
проектирования с множеством вариантов реализации. Обычно, производитель и
потребитель связываются потокобезопасной очередью задач, в которую пишет
один или несколько производителей и читает один или несколько потребителей. В
этой части необходимо разработать несколько реализаций потокобезопасной
очереди сообщений.
Задача. Написать код инстанцирующий ConsumerNum потребителей и
ProducerNum производителей. Связать их потокобезопасной очередью, хранящей
однобайтные элементы. Потребители инстанциируют локальный счетчик, после
чего начинают читать очередь и прибавлять вычитанные значения к локальному
счетчику. Каждый производитель записывает TaskNum единиц в очередь и
завершает свою работу. Когда все производители записали свои сообщения и
потребители опустошили очередь, потребители завершают свою работу и
возвращают получившиеся суммы. Необходимо засечь время работы
производителей и потребителей и проверить, что итоговая сумма результатов всех
потребителей равна ProducerNum / TaskNum. Протестировать для
**ProducerNum={1, 2, 4}**,**ConsumerNum={1, 2, 4}**, `TaskNum=4*1024*1024`.
Интерфейс очереди:
```
class queue
{
public:
 // Записывает элемент в очередь.
 // Гсли очередь фиксированного размер и заполнена,
 // поток повисает внутри функции пока не освободится место
 void push(uint8_t val);
 // Если очередь пуста, ждем 1 мс записи в очередь.
 // Если очередь не пуста, помещает значение головы в val,
 // удаляет голову и возвращает true.
 // Если очередь по прежнему пуста, возвращаем false
 bool pop(uint8_t& val);
};
```
Задачу необходимо решить для следующий вариантов реализации очереди:

1. Динамическая очередь с использованием std-контейнеров и `std::mutex`.
2. Очередь фиксированного размера QueueSize с использованием `std::mutex` и
`std::condition_variable` без busy wait. Протестировать для **QueueSize={1, 4, 16}**.
3. Очередь фиксированного размера с использованием `std::atomic`. Используйте
`std::conditinal_variable` и `std::mutex` только чтобы оповещать потоки об
освободившихся ячейках или новых задачах Протестировать для
**QueueSize={1, 4, 16}**
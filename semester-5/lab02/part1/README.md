## Часть 1. Параллельный обход массива элементов.
Пусть нам дан массив из NumTasks однотипных элементом которые надо
обработать NumThreads потоками. Если сложность обработки всех элементов
приблизительно одинакова, то можно разбить массив на NumThreads частей
состоящих из примерно NumTasks/NumThreads элементов и обработать каждую
часть последовательно в отдельном треде. Однако, если время работы сильно
зависит от значения элемента массива или случайно, то статическое планирование
может оказаться невыгодным. Пример: чтение сотни тысяч файлов с диска
размеров от 4Кб до 1Мб. В данном случае мы можем использовать общий
потокобезопасный счетчик, значение которого есть индекс первого
необработанного элемента. Каждый поток запрашивает индекс следующего
необработанного элемента и увеличивает счетчик на 1. Если полученный индекс
меньше NumTasks, поток запускает обработку указанного элемента, иначе
завершает свою работу.
Задача. Написать функцию, которая инстанцирует массив из NumTasks байт, в
каждом из которых записан 0. Запустить NumThreads потоков, каждый из которых
читает потокобезопасный индекс, увеличивает его на один и прибавляет единицу к
элементу массива по этому индексу. Засечь время работы всех потоков. После
завершения работы всех потоков, необходимо проверить корректность заполнения
массива и вывести на экран время работы.

1. Реализовать потокобезопасный счетчик двумя способами: блокирующий при
помощи `std::mutex` и неблокирующий при помощи `std::atomic`
2. Измерить время работы функции, использующей разные реализации
счетчика при `NumTasks=1024*1024` и **NumThreads={4, 8, 16, 32}**.
3. Добавьте усыпление потока на **10ns** после каждого инкремента элемента
массива. Повторите измерения из пункта 2.
